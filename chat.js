/**
 * @fileoverview
 * simpler, more robust(?) wrapper around the PeerJS API, for now geared to chat use.
 * @see http://peerjs.com
 *
 * todo: generalize some more. expose/support file transfers, calls/media etc.
 * todo: handle reconnect.. (possible to keep connected across a 4g<->wifi roam?)
 * todo: showstopper: peerjs doesn't handle https!! https://github.com/peers/peerjs/issues/118  -> no webcam..
 * todo: hmm, or migrate to use some kind of reactive pattern!? we are kindof working in a mix between promies and signals!(?)
 *
 // todo: Peerjs docs list this.. test anyway?
 var peer = new Peer({
   config: {'iceServers': [
     { url: 'stun:stun.l.google.com:19302' },
     { url: 'turn:homeo@turn.bistri.com:80', credential: 'homeo' }
 ]} // Sample servers, please use appropriate ones
 });
 *
 * @author Fredrik Blomqvist
 *
 */
define([
	RELEASE ? 'polyfills/es6-promise.min' : 'polyfills/es6-promise', // todo: should maybe be injected by default always somehow?
	RELEASE ? 'jquery.min' : 'jquery', // todo: drop. only $.extend is used now
	// 'blq',
	'blq/assert',
	'blq/xirsys',
	'blq/promise',
	'peer'
], function(_es6pp, $, /*blq,*/ assert, xirsys, async) {

if (RELEASE) {
	// ?? no jQuery AMD in minified mode?
	$ = jQuery;
}

// application singleton/namespace. todo: change to "real" class?
// @see http://peerjs.com/docs
var chat = {

	// PeerJS object. set after initialize()
	peer: null,

	settings: {
		// todo: hmm, use this _and_ a custom log?
		logFunction: function() {
			console.log.apply(console, arguments);
		}
	},

	// PeerJS account (can run our own also)
	// @see http://peerjs.com/peerserver
	// todo: create manual auth code?
	key: 'x7fwx2kavpy6tj4i',

	_auth: {
		// XirSys account for STUN/TURN service (default is only google's STUN)
		// necessary for true "in-the-open" connections, i.e cellular networks (TURN)
		// todo: other sources for TURN services?
		xirsys_account: {
			identity: 'fblq',
			domain: 'blqp2p.com',
			secret: '2955ebd0-8db4-42da-ae62-fed8ba8eb08b',
			// kindof optional, for a single test 'default' will probably do.
			// todo: would be nice to expose somehow?
			application: 'default',
			room: 'default'
		},

		// filled after authentication
		xirsys_auth: null
	},

	//--------

	// todo: make private?
	// id -> peer
	connectedPeers: {},

	// --- methods ---

	// called indirectly from initialize()
	// cached
	authenticate: function() {
		// sniff for XirSys, if not, fallback to default STUN. Only STUN (no xirsys) will probably work on a local network but most likely fail when on a cellular network.
		// todo: use a more generic injector for auth
		if (xirsys != null && typeof xirsys.getXirSysIceServerAuth == 'function') {
			if (chat._auth.xirsys_auth == null) {
				// todo: support more than xirsys
				return xirsys.getXirSysIceServerAuth(chat._auth.xirsys_account).then(function(auth) {
					console.log('XirSys auth obtained:', auth);
					// cache (todo: cache deeper in LS?)
					return chat._auth.xirsys_auth = auth;
				});
			} else {
				return Promise.resolve(chat._auth.xirsys_auth);
			}
		} else {
			var msg = 'No TURN service authentication available! Use default STUN. Will probably not work from a cellular network.';
			console.warn(msg);
			return Promise.resolve(msg);
		}
	},

	// id is optional, autogenerated (returns actualy id)
	initialize: async.lockPromiseCall(function(id) {
		return chat.authenticate().then(function(auth) {
			// todo: guard against double-init?
			// (todo: should actually delay assigning before ready)
			chat.peer = new Peer(typeof id == 'string' ? id : null, {
				// Set API key for Peerjs' cloud server (you don't need this if you're running your own).
				// todo: support XirSys here!
				// key: chat.key,
				// key: null,

				// test my own https://github.com/peers/peerjs-server deployed at Heroku! https://arks.herokuapp.com/
			/* ! plain http works!
				secure: false,
				key: 'peerjs',
				host: 'arks.herokuapp.com',
				port: 80, // 80 should be possible to skip
				path: '/',
			*/
				/* works! */
				secure: true,
				key: 'peerjs', // ? seems we must use this anyway for args to match..
				host: 'arks.herokuapp.com',
				// port: 80, // ! in https mode heroku doesn't accept passing in ":80"(!?) -> patched peerjs to drop a null-port (at least better than stringifying null as previously..) -> todo: report to Peerjs!
				port: null,
				path: '/',
				//-----------

				// secure: true, // dang! Peerjs doesn't support https!

				// todo: XirSys or other! (hope they have https..)
				// test https://github.com/andyet/SimpleWebRTC server. doesn't work? not same conventions?
				// host: 'https://sandbox.simplewebrtc.com',
				// port: 443,
				// port: 8000,
				// path: '',
				// host: 'apprtc-ws.webrtc.org',
				// port: 443,
				// secure: true,
				// path: 'ws',

				config: auth,

				// Set highest debug level (log everything!).
				debug: 3,

				logFunction: function() {
					chat.settings.logFunction.apply(this, arguments);
				}
			});


			return new Promise(function(resolve, reject) {

				function _resolve(id) {
					chat.peer.removeListener('error', _reject);
					//if (d.state() == 'pending')
						resolve(id);
					//else
					//	console.warn('Peer promise double resolve!?');
				}
				function _reject(err) {
					chat.peer.removeListener('open', _resolve);
					//if (d.state() == 'pending')
						reject(err);
					//else
					//	console.warn('Peer promise double reject!?');
				}

				// can actually connect to other Peers before 'open' event
				// but guess this is more easy to follow
				// @see http://peerjs.com/docs/#peeron-open
				chat.peer.once('open', _resolve);
				chat.peer.once('error', _reject);

				// await connections from others
				// todo: bug(?) should keep track of cyclic connections! (at least in this "app". could allow technically)
				// todo: possibly place this even closer/before open callback? some race bug(!?)
				chat.peer.on('connection', function(c) {
					console.log('peer:connection (incoming)', c);
					// todo: should we buffer incoming? if a user starts listening for a label should he not get into a race?
					chat._addConnection(c);
				});

				console.debug('Peer: attaching permanent listeners');
				// permanent listeners
				chat.peer.on('open', function() {
					console.log('peer:open');
				});
				chat.peer.on('close', function() {
					console.log('peer:close');
				});
				chat.peer.on('error', function(err) {
					console.error('peer:error', err);
				});

			});
		});
	}),

	_addConnection: function(c) {
		if (c.peer in chat.connectedPeers)
			console.debug('incoming: overwriting connected Peer?');
		chat.connectedPeers[c.peer] = c;
		console.debug(Object.keys(chat.connectedPeers).length, 'connected Peers');
		// permanent listeners
		c.on('open', function() {
			console.log('connection open:', c);
			if (c.peer in chat.connectedPeers)
				console.debug('outgoing: overwriting a connected Peer?');
			chat.connectedPeers[c.peer] = c;
			console.debug(Object.keys(chat.connectedPeers).length, 'connected Peers');
		});
		// PeerJS docs claim 'close' doesn't work in FF? todo: verify in latest FF
		c.on('close', function() {
			console.log('connection close:', c);
			delete chat.connectedPeers[c.peer];
			console.debug(Object.keys(chat.connectedPeers).length, 'connected Peers');
		});
		c.on('error', function(err) {
			console.error('connection err:', err);
		});

		c.on('data', function(data) {
			console.debug('connection:ondata', data);
		});
	},

	// data connection. todo: media. call
	// caches connections also
	openPeerConnection: function(peerId, options) {
		// todo: block if initialize hasn't been run?
		return new Promise(function(resolve, reject) {

			if (chat.peer == null) {
				var msg = 'Can\'t open a connection before initialized!';
				console.error(msg);
				reject(msg);
				return;
			}

			// todo: need a flag to block double opening if pending!
			// (yes, even though it's the caller that is not using it
			// correctly if calling before promise trigger)
			// hmm, let the dict contain Promises?
			var c = chat.connectedPeers[peerId];
			if (!c) {
				c = chat.peer.connect(peerId, $.extend(true, {
					label: 'chat',
					serialization: 'json', // 'binary' (default), 'binary-utf8', 'json', or 'none'. todo: create an enum?
					metadata: {
						// todo: can add anything here! typically at least actual usernames etc
						message: 'hi i want to chat with you!'
					}
					// , reliable: false // only set to true for large files
				}, options));
				if (c == null) {
					var msg = 'peer.connect returned null. Probably invalid init';
					console.warn(msg);
					reject(msg); // (hmm, why doesn't reject/resolve return a promise directly?)
					return;
				}
				assert(c.type == 'data');

				var _resolve = function() {
					// try doing more things directly in this callback to avoid possible race(!?)
					c.removeListener('error', _reject);
					//if (d.state() == 'pending') {
						chat._addConnection(c);
						resolve(c);
					//} else
					//	console.debug('connection promise double resolve!?');
				};
				var _reject = function(err) {
					c.removeListener('open', _resolve);
					//if (d.state() == 'pending')
						reject(err);
					//else
					//	console.debug('connection promise double reject!?');
				};

				// 1) handle the Promise
				c.once('open', _resolve);
				c.once('error', _reject);

				// todo: add to connectedPeers but with pending state?
			} else {
				console.debug('connection already exist');
				resolve(c);
			}
			// chat.connectedPeers[c.peer] = c;

		});
	},

	// incoming
	// todo: support this to be done before full initialization?
	// got a case with immediate callback from chat->video when this is too late!)
	listenForConnection: function(label, callback) {
		chat.peer.on('connection', function(c) {
			if (c.label == label)
				callback(c);
		});
	},

	// todo: hmm. fuzzy with available vs also connected/open..
	isPeerConnected: function(peerId) {
		var c = chat.connectedPeers[peer];
		return c != null && c.open;  // hmm
	},

	// closePeerConnection: function(cid) {
	// 	// todo: keep in dict?
	// },

	// Goes through each peer and calls FN on its connections.
	// todo: expose a real iterator?
	eachConnection: function(fn) {
		for (var peerId in chat.connectedPeers) {
			if (peerId != chat.connectedPeers[peerId].peer)
				console.debug('peer id mismatch!?');
			var conns = chat.peer.connections[peerId];
			// iterate backwards so we can allow disconnects (ok?)
			for (var i = conns.length - 1; i >= 0; --i) {
				var conn = conns[i];
				var ret = fn(conn);
				if (ret === false)
					return; // break all
			}
		}
	},

	closeAllConnections: function() {
		chat.eachConnection(function(c) {
			c.close();
		});
	},

	// todo: hmm, some kind of return val?
	broadCast: function(msg, label) {
		// label = label || 'chat';
		chat.eachConnection(function(c) {
			if (c.label == label)
				c.send(msg);
		});
	},

	// todo: should we perhaps automatically hook to window.unload? (setting.bindToPage?)
	// todo: name? destroy? dispose?
	teardown: function() {
		console.log('Tearing down Peer2Peer...');
		if (chat.peer != null && !chat.peer.destroyed) {
			chat.peer.destroy();
			chat.peer = null;
			chat.connectedPeers = {};
			chat._auth.xirsys_auth = null; // not really necessary but anyway
		}
	}
}; // chat


return chat;

}); // define
